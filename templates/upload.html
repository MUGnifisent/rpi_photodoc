{% extends "base.html" %}
{% block title %}Upload & Process Image{% endblock %}

{% block head %}
{{ super() }}
<style>
    .upload-page-container {
        max-width: 600px;
        margin: 3rem auto; /* Vertical margin for better spacing */
    }
    .camera-feed {
        max-width: 100%;
        height: auto;
        border: 1px solid #4a4a4a; /* From style.css */
        margin-bottom: 1rem;
        border-radius: 4px; /* From style.css */
        background-color: #2c2c2c; /* Match input fields */
        min-height: 240px; /* Default minimum height */
    }
    .file-label .file-name {
        border-width: 1px; /* Ensure file name area also has border */
    }
    /* For loading spinner on buttons */
    .button.is-loading::after {
        border-color: transparent transparent #fff #fff !important; /* White spinner for dark buttons */
    }
    #rpi-camera-section .subtitle,
    #rpi-camera-section-unavailable .subtitle {
        min-height: 2.5em; /* Space for status messages */
        padding-bottom: 0.5rem;
    }
    .camera-feed-container {
        position: relative;
        display: inline-block; /* To wrap around the image */
        background-color: #2c2c2c; /* Match input fields for placeholder bg */
        min-height: 240px; /* Default minimum height */
        width: 100%; /* Take full width of its parent */
        border-radius: 4px;
        display: flex; /* For centering loading text */
        align-items: center;
        justify-content: center;
        border: 1px solid #4a4a4a;
    }
    .camera-feed {
        max-width: 100%;
        height: auto;
        /* border: 1px solid #4a4a4a; */ /* Moved to container */
        margin-bottom: 1rem;
        border-radius: 4px;
        /* background-color: #2c2c2c; */ /* Moved to container */
        /* min-height: 240px; */ /* Default minimum height - on container now */
        display: block; /* Ensure it behaves as a block element */
    }
    .camera-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9a9a9a;
        font-style: italic;
        z-index: 10; /* Ensure it's above the img if it loads a broken icon */
        /* background-color: rgba(0,0,0,0.3); Optional: slight dimming */
    }
</style>
{% endblock %}

{% block content %}
<section class="section">
    <div class="container upload-page-container">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="notification is-{{ 'danger' if category == 'error' else category }} is-light is-small mb-4" id="flash-message-{{ loop.index }}">
                        <button class="delete is-small" onclick="this.parentElement.remove();"></button>
                        {{ message }}
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}

        <div class="box" id="upload-box">
            <h1 class="title is-3 has-text-centered">Process New Image</h1>
            <p class="subtitle is-6 has-text-centered has-text-grey-light mb-5">Upload an image file (PNG, JPG, WEBP) to extract text.</p>
            
            <form method="POST" action="{{ url_for('main.process_upload') }}" enctype="multipart/form-data" id="upload-form">
                <div class="field">
                    <label class="label">Image File</label>
                    <div class="file is-primary has-name is-boxed is-fullwidth">
                        <label class="file-label">
                            <input class="file-input" type="file" name="file" accept="image/png, image/jpeg, image/webp" id="file-upload-input">
                            <span class="file-cta">
                                <span class="file-icon"><i class="fas fa-upload"></i></span>
                                <span class="file-label">Choose a fileâ€¦</span>
                            </span>
                            <span class="file-name">No file selected</span>
                        </label>
                    </div>
                </div>
                 <div id="upload-form-error-placeholder" class="mt-2"></div> <!-- For JS-based errors -->

                <div class="field mt-5">
                    <div class="control">
                        <button type="submit" class="button is-primary is-fullwidth is-medium" id="upload-submit-button">
                            <span class="icon"><i class="fas fa-cogs"></i></span>
                            <span>Upload and Process</span>
                        </button>
                    </div>
                </div>
            </form>
        </div>

        {% if camera_available %}
        <div class="box mt-5" id="rpi-camera-section">
            <h2 class="title is-4 has-text-centered">RPi Camera</h2>
            <p class="subtitle is-6 has-text-centered has-text-grey-light mb-4" id="camera-status-text">Checking camera status...</p>
            <div class="has-text-centered camera-feed-container" id="camera-feed-container">
                 <img src="{{ url_for('static', filename='img/image_placeholder.png') }}" alt="Camera Feed" id="camera-feed-img" class="camera-feed" style="display: none;"/>
                 <div class="camera-loading-overlay" id="camera-loading-overlay" style="display: none;">Loading camera...</div>
            </div>
            <button class="button is-link is-fullwidth mb-2 mt-4" id="start-camera-btn" disabled>
                <span class="icon"><i class="fas fa-video"></i></span>
                <span>Start Camera</span>
            </button>
            <button class="button is-danger is-fullwidth mb-2 mt-4" id="stop-camera-btn" style="display:none;">
                <span class="icon"><i class="fas fa-video-slash"></i></span>
                <span>Stop Camera</span>
            </button>
            <button class="button is-primary is-fullwidth" id="capture-photo-btn" style="display:none;" disabled>
                <span class="icon"><i class="fas fa-camera"></i></span>
                <span>Capture Photo & Process</span>
            </button>
            <div id="capture-message-placeholder" class="mt-3"></div>
        </div>
        {% else %}
        <div class="box mt-5 is-hidden-touch" id="rpi-camera-section-unavailable">
             <h2 class="title is-4 has-text-centered">RPi Camera</h2>
             <p class="subtitle is-6 has-text-centered has-text-grey-light mb-4">RPi Camera feature is not available on this device or the camera is not detected.</p>
             <div class="has-text-centered">
                <span class="icon is-large has-text-grey-light"><i class="fas fa-exclamation-triangle fa-3x"></i></span>
             </div>
        </div>
        {% endif %}
    </div>
</section>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('file-upload-input');
    const fileNameDisplay = document.querySelector('.file-name');
    if (fileInput && fileNameDisplay) {
        fileInput.onchange = () => {
            if (fileInput.files.length > 0) {
                fileNameDisplay.textContent = fileInput.files[0].name;
            } else {
                fileNameDisplay.textContent = "No file selected";
            }
        }
    }

    const uploadForm = document.getElementById('upload-form');
    const uploadSubmitButton = document.getElementById('upload-submit-button');
    const uploadFormErrorPlaceholder = document.getElementById('upload-form-error-placeholder');

    if (uploadForm && uploadSubmitButton) {
        uploadForm.addEventListener('submit', (event) => {
            if (fileInput && fileInput.files.length === 0) {
                event.preventDefault();
                displayNotification('Please select a file to upload.', 'warning', uploadFormErrorPlaceholder, true);
                return;
            }
            uploadSubmitButton.classList.add('is-loading');
            uploadSubmitButton.disabled = true;
        });
    }

    function displayNotification(message, type = 'info', container, isFormError = false) {
        if (!container) {
            console.warn("Notification container not found for message:", message);
            // Fallback to a generic alert if no container and not a form error
            if(!isFormError) alert(message);
            return;
        }
        let notificationDiv = container.querySelector('.notification'); // Try to reuse existing for form errors
        if (!notificationDiv || !isFormError) { // Always create new for non-form errors or if no existing
            if(isFormError) container.innerHTML = ''; // Clear previous form error
            notificationDiv = document.createElement('div');
            notificationDiv.className = `notification is-${type} is-light is-small mb-3`;
            container.appendChild(notificationDiv);
        } else { // Update existing form error notification
             notificationDiv.className = `notification is-${type} is-light is-small mb-3`; // Update class for new type
        }
        
        notificationDiv.innerHTML = `<button class="delete is-small"></button>${message}`;
        const deleteButton = notificationDiv.querySelector('.delete');
        if (deleteButton) {
            deleteButton.addEventListener('click', () => notificationDiv.remove());
        }
    }

    const cameraSection = document.getElementById('rpi-camera-section');
    if (cameraSection) { // Only run camera JS if the section is present (i.e., camera_available was true)
        const cameraFeedImg = document.getElementById('camera-feed-img');
        const cameraFeedContainer = document.getElementById('camera-feed-container');
        const cameraLoadingOverlay = document.getElementById('camera-loading-overlay');
        const startCameraButton = document.getElementById('start-camera-btn');
        const stopCameraButton = document.getElementById('stop-camera-btn');
        const capturePhotoButton = document.getElementById('capture-photo-btn');
        const cameraStatusText = document.getElementById('camera-status-text');
        const captureMessagePlaceholder = document.getElementById('capture-message-placeholder');
        const defaultPlaceholderSrc = "{{ url_for('static', filename='img/image_placeholder.png') }}";
        let streamActive = false;

        function showCameraLoading(text = "Loading camera...") {
            cameraFeedImg.style.display = 'none'; // Hide image if shown
            cameraFeedImg.src = '#'; // Prevent broken icon if placeholder was there
            cameraLoadingOverlay.textContent = text;
            cameraLoadingOverlay.style.display = 'flex';
            cameraFeedContainer.style.minHeight = '240px'; // Ensure container has height
        }

        function showCameraPlaceholder() {
            cameraLoadingOverlay.style.display = 'none';
            cameraFeedImg.src = defaultPlaceholderSrc;
            cameraFeedImg.style.display = 'block';
            cameraFeedContainer.style.minHeight = '0'; // Reset min height when placeholder shown
        }

        function showLiveFeed() {
            cameraLoadingOverlay.style.display = 'none';
            cameraFeedImg.src = "{{ url_for('main.camera_feed') }}?_nocache=" + new Date().getTime();
            cameraFeedImg.style.display = 'block';
            cameraFeedContainer.style.minHeight = '0'; // Reset min height
        }

        async function checkCameraStatus() {
            // cameraStatusText.textContent = "Checking camera status...";
            showCameraLoading("Checking camera status...");
            startCameraButton.disabled = true;
            capturePhotoButton.disabled = true; // Disable until status known
            try {
                const response = await fetch("{{ url_for('main.camera_status') }}");
                const data = await response.json();
                if (data.available) {
                    startCameraButton.disabled = false; // Enable if available
                    if (data.streaming) {
                        activateStreamUI();
                        cameraStatusText.textContent = "Camera live."; // Update text here
                    } else {
                        // Camera is available but not streaming
                        showCameraPlaceholder();
                        startCameraButton.style.display = 'block';
                        stopCameraButton.style.display = 'none';
                        capturePhotoButton.style.display = 'none'; // Hide capture button if not streaming
                        capturePhotoButton.disabled = true;
                        cameraStatusText.textContent = "Camera ready. Press Start.";
                        streamActive = false;
                    }
                } else {
                    cameraStatusText.textContent = data.message || "RPi Camera not available.";
                    showCameraPlaceholder(); // Show placeholder if not available
                    startCameraButton.style.display = 'block';
                    startCameraButton.disabled = true;
                    stopCameraButton.style.display = 'none';
                    capturePhotoButton.style.display = 'none';
                    capturePhotoButton.disabled = true;
                    streamActive = false;
                }
            } catch (error) {
                console.error("Error checking camera status:", error);
                cameraStatusText.textContent = "Error checking camera status.";
                showCameraPlaceholder(); // Show placeholder on error
                startCameraButton.style.display = 'block';
                startCameraButton.disabled = true;
                stopCameraButton.style.display = 'none';
                capturePhotoButton.style.display = 'none';
                capturePhotoButton.disabled = true;
                streamActive = false;
            }
        }

        function activateStreamUI() {
            // cameraFeedImg.src = "{{ url_for('main.camera_feed') }}?_nocache=" + new Date().getTime();
            showLiveFeed();
            startCameraButton.style.display = 'none';
            stopCameraButton.style.display = 'block';
            stopCameraButton.disabled = false;
            capturePhotoButton.style.display = 'block';
            capturePhotoButton.disabled = false;
            cameraStatusText.textContent = "Camera live."; // Ensure text is set here too
            streamActive = true;
        }

        function deactivateStreamUI(statusText = "Camera stopped.") {
            showCameraPlaceholder();
            startCameraButton.style.display = 'block';
            // If camera was available, start button should be enabled by checkCameraStatus or its direct handling path.
            // We only disable it if camera becomes unavailable.
            // startCameraButton.disabled = !rpi_camera_instance.is_available(); // This logic is now in checkCameraStatus

            stopCameraButton.style.display = 'none';
            capturePhotoButton.style.display = 'none';
            capturePhotoButton.disabled = true; 
            cameraStatusText.textContent = statusText;
            streamActive = false;
            // DO NOT call checkCameraStatus() here to prevent recursion.
            // The states of buttons should be managed by the function that led to deactivation or a fresh checkCameraStatus call.
        }

        startCameraButton.addEventListener('click', async () => {
            startCameraButton.classList.add('is-loading');
            startCameraButton.disabled = true;
            // cameraStatusText.textContent = "Starting camera...";
            showCameraLoading("Starting camera...");
            capturePhotoButton.disabled = true; // Disable capture while starting
            try {
                const response = await fetch("{{ url_for('main.start_camera_stream') }}", { method: 'POST' });
                const result = await response.json();
                if (response.ok && result.success) {
                    activateStreamUI();
                } else {
                    const errorMsg = "Failed to start camera: " + (result.error || "Unknown error");
                    deactivateStreamUI(errorMsg); // This will call showCameraPlaceholder
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                }
            } catch (error) {
                console.error("Error starting camera:", error);
                const errorMsg = "Error starting camera: " + error.message;
                deactivateStreamUI(errorMsg); // This will call showCameraPlaceholder
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
            }
            startCameraButton.classList.remove('is-loading');
            // Button state will be set by checkCameraStatus called in deactivateStreamUI or by direct activation
        });

        stopCameraButton.addEventListener('click', async () => {
            stopCameraButton.classList.add('is-loading');
            stopCameraButton.disabled = true;
            capturePhotoButton.disabled = true; // Disable capture while stopping
            // cameraStatusText.textContent = "Stopping camera..."; // Replaced by showCameraLoading
            showCameraLoading("Stopping camera...");
            try {
                const response = await fetch("{{ url_for('main.stop_camera_stream') }}", { method: 'POST' });
                const result = await response.json();
                if (response.ok && result.success) {
                    // When stopping, we go to a state where camera is ready but not streaming.
                    // So, directly set that state rather than calling deactivateStreamUI which might call checkCameraStatus.
                    showCameraPlaceholder();
                    startCameraButton.style.display = 'block';
                    startCameraButton.disabled = false; // Camera is still available
                    stopCameraButton.style.display = 'none';
                    capturePhotoButton.style.display = 'none';
                    capturePhotoButton.disabled = true;
                    cameraStatusText.textContent = "Camera stopped. Press Start to resume.";
                    streamActive = false;
                } else {
                    const errorMsg = "Failed to stop camera: " + (result.error || "Unknown error");
                    cameraStatusText.textContent = errorMsg;
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                    stopCameraButton.disabled = false; 
                    if(streamActive) capturePhotoButton.disabled = false; // Re-enable if stream was active
                    else showCameraPlaceholder(); // Ensure placeholder if error and not streaming
                }
            } catch (error) {
                console.error("Error stopping camera:", error);
                const errorMsg = "Error stopping camera: " + error.message;
                cameraStatusText.textContent = errorMsg;
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                stopCameraButton.disabled = false; 
                if(streamActive) capturePhotoButton.disabled = false;
                else showCameraPlaceholder();
            }
            stopCameraButton.classList.remove('is-loading');
        });

        capturePhotoButton.addEventListener('click', async () => {
            capturePhotoButton.classList.add('is-loading');
            capturePhotoButton.disabled = true;
            startCameraButton.disabled = true; // Prevent starting during capture
            stopCameraButton.disabled = true; // Prevent stopping during capture
            
            // Clear previous messages
            if (captureMessagePlaceholder) captureMessagePlaceholder.innerHTML = '';
            displayNotification('Capturing and processing photo...', 'info', captureMessagePlaceholder);

            try {
                const response = await fetch("{{ url_for('main.capture_rpi_photo') }}", { method: 'POST' });
                const result = await response.json();

                if (response.ok && result.success) {
                    displayNotification(result.message || 'Photo captured and processed successfully!', 'success', captureMessagePlaceholder);
                    if (result.redirect_url) {
                        // Give a moment for the user to see the success message
                        setTimeout(() => {
                            window.location.href = result.redirect_url;
                        }, 1500);
                    } else if (result.warning) { // Handle cases where document creation might have failed
                        displayNotification(result.warning, 'warning', captureMessagePlaceholder);
                        // Stay on page, photo is processed, but doc needs manual creation
                    }
                } else {
                    const errorMsg = "Capture/Processing failed: " + (result.error || "Unknown error");
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                    capturePhotoButton.disabled = false; // Re-enable on failure
                }
            } catch (error) {
                console.error("Error capturing photo:", error);
                const errorMsg = "Error during capture: " + error.message;
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                capturePhotoButton.disabled = false; // Re-enable on error
            }
            // Don't remove loading immediately if redirecting, but do if staying on page
            if (!capturePhotoButton.disabled) { // Only remove if not disabled (i.e. not about to redirect)
                 capturePhotoButton.classList.remove('is-loading');
            }
            // Re-evaluate camera state for other buttons if not redirecting
            if (!capturePhotoButton.disabled) {
                 checkCameraStatus(); 
            }
        });

        // Initial check
        checkCameraStatus();
    } // End of camera_available block

    // Generic handler for dismissing server-side flash messages (if any remain)
    document.querySelectorAll('.notification .delete').forEach((deleteButton) => {
        if (!deleteButton.dataset.listenerAttached) { // Avoid double-binding if displayNotification already handled it
            deleteButton.addEventListener('click', () => {
                deleteButton.parentElement.remove();
            });
            deleteButton.dataset.listenerAttached = 'true';
        }
    });
});
</script>
{% endblock %} 