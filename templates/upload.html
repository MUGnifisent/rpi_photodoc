{% extends "base.html" %}
{% block title %}Upload & Process Image{% endblock %}

{% block head %}
{{ super() }}
<style>
    .upload-page-container {
        max-width: 600px;
        margin: 3rem auto; /* Vertical margin for better spacing */
    }
    .camera-feed {
        max-width: 100%;
        height: auto;
        border: 1px solid #4a4a4a; /* From style.css */
        margin-bottom: 1rem;
        border-radius: 4px; /* From style.css */
        background-color: #2c2c2c; /* Match input fields */
        min-height: 240px; /* Default minimum height */
    }
    .file-label .file-name {
        border-width: 1px; /* Ensure file name area also has border */
    }
    /* For loading spinner on buttons */
    .button.is-loading::after {
        border-color: transparent transparent #fff #fff !important; /* White spinner for dark buttons */
    }
    #rpi-camera-section .subtitle,
    #rpi-camera-section-unavailable .subtitle {
        min-height: 2.5em; /* Space for status messages */
        padding-bottom: 0.5rem;
    }
    .camera-feed-container {
        position: relative;
        display: none; /* Only show when live */
        align-items: center;
        justify-content: center;
        background-color: #2c2c2c;
        min-height: 240px;
        width: 100%;
        border-radius: 4px;
        border: 1px solid #4a4a4a;
        overflow: hidden;
        transition: box-shadow 0.2s;
    }
    .camera-feed-container.visible {
        display: flex;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.12);
    }
    .camera-feed {
        max-width: 100%;
        max-height: 240px;
        width: auto;
        height: auto;
        margin-bottom: 0;
        border-radius: 4px;
        display: none;
        object-fit: contain;
        background: #222;
        transition: transform 0.3s;
    }
    .camera-feed.visible {
        display: block;
    }
    .camera-feed.portrait {
        transform: rotate(90deg);
        max-width: 240px;
        max-height: 100%;
    }
    .camera-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9a9a9a;
        font-style: italic;
        z-index: 10;
    }
    .button.upload-flat {
        background: #2563eb;
        color: #fff;
        border: none;
        border-radius: 6px;
        box-shadow: none;
        font-weight: 600;
        font-size: 1.1rem;
        padding: 0.75em 1.5em;
        transition: background 0.2s, box-shadow 0.2s;
        margin-top: 1em;
    }
    .button.upload-flat:hover, .button.upload-flat:focus {
        background: #1d4ed8;
        color: #fff;
        box-shadow: 0 2px 8px 0 rgba(37,99,235,0.10);
    }
    .autofocus-controls {
        display: flex;
        gap: 1em;
        justify-content: center;
        align-items: center;
        margin-bottom: 1em;
    }
    .autofocus-status {
        font-size: 0.95em;
        color: #6ee7b7;
        margin-left: 0.5em;
    }
</style>
{% endblock %}

{% block content %}
<section class="section">
    <div class="container upload-page-container">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="notification is-{{ 'danger' if category == 'error' else category }} is-light is-small mb-4" id="flash-message-{{ loop.index }}">
                        <button class="delete is-small" onclick="this.parentElement.remove();"></button>
                        {{ message }}
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}

        <div class="box" id="upload-box">
            <h1 class="title is-3 has-text-centered">Process New Image</h1>
            <p class="subtitle is-6 has-text-centered has-text-grey-light mb-5">Upload an image file (PNG, JPG, WEBP) to extract text.</p>
            
            <form method="POST" action="{{ url_for('main.process_upload') }}" enctype="multipart/form-data" id="upload-form">
                <div class="field">
                    <label class="label">Image File</label>
                    <div class="file is-primary has-name is-boxed is-fullwidth">
                        <label class="file-label">
                            <input class="file-input" type="file" name="file" accept="image/png, image/jpeg, image/webp" id="file-upload-input">
                            <span class="file-cta">
                                <span class="file-icon"><i class="fas fa-upload"></i></span>
                                <span class="file-label">Choose a fileâ€¦</span>
                            </span>
                            <span class="file-name">No file selected</span>
                        </label>
                    </div>
                </div>
                 <div id="upload-form-error-placeholder" class="mt-2"></div> <!-- For JS-based errors -->

                <div class="field mt-5">
                    <div class="control has-text-centered">
                        <button type="submit" class="button upload-flat is-fullwidth is-medium" id="upload-submit-button">
                            <span class="icon"><i class="fas fa-cogs"></i></span>
                            <span>Upload and Process</span>
                        </button>
                    </div>
                </div>
            </form>
        </div>

        {% if camera_available %}
        <div class="box mt-5" id="rpi-camera-section">
            <h2 class="title is-4 has-text-centered">RPi Camera</h2>
            <p class="subtitle is-6 has-text-centered has-text-grey-light mb-4" id="camera-status-text">Checking camera status...</p>
            <div class="has-text-centered mb-3 autofocus-controls">
                <button class="button is-small is-rounded" id="toggle-portrait-btn" type="button">
                    <span class="icon"><i class="fas fa-mobile-alt"></i></span>
                    <span id="portrait-btn-label">Portrait Mode: Off</span>
                </button>
                <button class="button is-small is-rounded" id="toggle-af-btn" type="button">
                    <span class="icon"><i class="fas fa-bullseye"></i></span>
                    <span id="af-btn-label">Autofocus: Off</span>
                </button>
                <button class="button is-small is-rounded" id="oneshot-af-btn" type="button">
                    <span class="icon"><i class="fas fa-crosshairs"></i></span>
                    <span>One-Shot AF</span>
                </button>
                <span class="autofocus-status" id="af-status"></span>
            </div>
            <div class="has-text-centered camera-feed-container" id="camera-feed-container">
                 <img src="" alt="Camera Feed" id="camera-feed-img" class="camera-feed"/>
                 <div class="camera-loading-overlay" id="camera-loading-overlay" style="display: none;">Loading camera...</div>
            </div>
            <button class="button is-link is-fullwidth mb-2 mt-4" id="start-camera-btn" disabled>
                <span class="icon"><i class="fas fa-video"></i></span>
                <span>Start Camera</span>
            </button>
            <button class="button is-danger is-fullwidth mb-2 mt-4" id="stop-camera-btn" style="display:none;">
                <span class="icon"><i class="fas fa-video-slash"></i></span>
                <span>Stop Camera</span>
            </button>
            <button class="button is-primary is-fullwidth" id="capture-photo-btn" style="display:none;" disabled>
                <span class="icon"><i class="fas fa-camera"></i></span>
                <span>Capture Photo & Process</span>
            </button>
            <div id="capture-message-placeholder" class="mt-3"></div>
        </div>
        {% else %}
        <div class="box mt-5 is-hidden-touch" id="rpi-camera-section-unavailable">
             <h2 class="title is-4 has-text-centered">RPi Camera</h2>
             <p class="subtitle is-6 has-text-centered has-text-grey-light mb-4">RPi Camera feature is not available on this device or the camera is not detected.</p>
             <div class="has-text-centered">
                <span class="icon is-large has-text-grey-light"><i class="fas fa-exclamation-triangle fa-3x"></i></span>
             </div>
        </div>
        {% endif %}
    </div>
</section>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('file-upload-input');
    const fileNameDisplay = document.querySelector('.file-name');
    if (fileInput && fileNameDisplay) {
        fileInput.onchange = () => {
            if (fileInput.files.length > 0) {
                fileNameDisplay.textContent = fileInput.files[0].name;
            } else {
                fileNameDisplay.textContent = "No file selected";
            }
        }
    }

    const uploadForm = document.getElementById('upload-form');
    const uploadSubmitButton = document.getElementById('upload-submit-button');
    const uploadFormErrorPlaceholder = document.getElementById('upload-form-error-placeholder');

    if (uploadForm && uploadSubmitButton) {
        uploadForm.addEventListener('submit', (event) => {
            if (fileInput && fileInput.files.length === 0) {
                event.preventDefault();
                displayNotification('Please select a file to upload.', 'warning', uploadFormErrorPlaceholder, true);
                return;
            }
            uploadSubmitButton.classList.add('is-loading');
            uploadSubmitButton.disabled = true;
        });
    }

    function displayNotification(message, type = 'info', container, isFormError = false) {
        if (!container) {
            console.warn("Notification container not found for message:", message);
            // Fallback to a generic alert if no container and not a form error
            if(!isFormError) alert(message);
            return;
        }
        let notificationDiv = container.querySelector('.notification'); // Try to reuse existing for form errors
        if (!notificationDiv || !isFormError) { // Always create new for non-form errors or if no existing
            if(isFormError) container.innerHTML = ''; // Clear previous form error
            notificationDiv = document.createElement('div');
            notificationDiv.className = `notification is-${type} is-light is-small mb-3`;
            container.appendChild(notificationDiv);
        } else { // Update existing form error notification
             notificationDiv.className = `notification is-${type} is-light is-small mb-3`; // Update class for new type
        }
        
        notificationDiv.innerHTML = `<button class="delete is-small"></button>${message}`;
        const deleteButton = notificationDiv.querySelector('.delete');
        if (deleteButton) {
            deleteButton.addEventListener('click', () => notificationDiv.remove());
        }
    }

    const cameraSection = document.getElementById('rpi-camera-section');
    if (cameraSection) { // Only run camera JS if the section is present (i.e., camera_available was true)
        const cameraFeedImg = document.getElementById('camera-feed-img');
        const cameraFeedContainer = document.getElementById('camera-feed-container');
        const cameraLoadingOverlay = document.getElementById('camera-loading-overlay');
        const startCameraButton = document.getElementById('start-camera-btn');
        const stopCameraButton = document.getElementById('stop-camera-btn');
        const capturePhotoButton = document.getElementById('capture-photo-btn');
        const cameraStatusText = document.getElementById('camera-status-text');
        const captureMessagePlaceholder = document.getElementById('capture-message-placeholder');
        const togglePortraitBtn = document.getElementById('toggle-portrait-btn');
        const portraitBtnLabel = document.getElementById('portrait-btn-label');
        const toggleAfBtn = document.getElementById('toggle-af-btn');
        const afBtnLabel = document.getElementById('af-btn-label');
        const oneshotAfBtn = document.getElementById('oneshot-af-btn');
        const afStatus = document.getElementById('af-status');
        let portraitMode = false;
        let afEnabled = false;
        let streamActive = false;

        function updatePortraitButton() {
            if (portraitMode) {
                portraitBtnLabel.textContent = 'Portrait Mode: On';
                cameraFeedImg.classList.add('portrait');
            } else {
                portraitBtnLabel.textContent = 'Portrait Mode: Off';
                cameraFeedImg.classList.remove('portrait');
            }
        }
        togglePortraitBtn.addEventListener('click', async () => {
            portraitMode = !portraitMode;
            updatePortraitButton();
            try {
                await fetch("{{ url_for('main.toggle_camera_orientation') }}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: portraitMode })
                });
            } catch (e) {
                displayNotification('Failed to toggle portrait mode.', 'danger', captureMessagePlaceholder);
            }
            if (streamActive) {
                showLiveFeed();
            }
        });
        function showCameraLoading(text = "Loading camera...") {
            cameraFeedContainer.classList.remove('visible');
            cameraFeedImg.classList.remove('visible');
            cameraFeedImg.src = '';
            cameraLoadingOverlay.textContent = text;
            cameraLoadingOverlay.style.display = 'flex';
        }
        function showCameraPlaceholder() {
            cameraFeedContainer.classList.remove('visible');
            cameraFeedImg.classList.remove('visible');
            cameraFeedImg.src = '';
            cameraLoadingOverlay.style.display = 'none';
        }
        function showLiveFeed() {
            cameraFeedContainer.classList.add('visible');
            cameraFeedImg.src = "{{ url_for('main.camera_feed') }}?_nocache=" + new Date().getTime();
            cameraFeedImg.classList.add('visible');
            cameraLoadingOverlay.style.display = 'none';
            updatePortraitButton();
            updateAfStateUI();
        }

        async function checkCameraStatus() {
            // cameraStatusText.textContent = "Checking camera status...";
            showCameraLoading("Checking camera status...");
            startCameraButton.disabled = true;
            capturePhotoButton.disabled = true; // Disable until status known
            try {
                const response = await fetch("{{ url_for('main.camera_status') }}");
                const data = await response.json();
                if (data.available) {
                    startCameraButton.disabled = false; // Enable if available
                    if (data.streaming) {
                        activateStreamUI();
                        cameraStatusText.textContent = "Camera live."; // Update text here
                    } else {
                        // Camera is available but not streaming
                        showCameraPlaceholder();
                        startCameraButton.style.display = 'block';
                        stopCameraButton.style.display = 'none';
                        capturePhotoButton.style.display = 'none'; // Hide capture button if not streaming
                        capturePhotoButton.disabled = true;
                        cameraStatusText.textContent = "Camera ready. Press Start.";
                        streamActive = false;
                    }
                } else {
                    cameraStatusText.textContent = data.message || "RPi Camera not available.";
                    showCameraPlaceholder(); // Show placeholder if not available
                    startCameraButton.style.display = 'block';
                    startCameraButton.disabled = true;
                    stopCameraButton.style.display = 'none';
                    capturePhotoButton.style.display = 'none';
                    capturePhotoButton.disabled = true;
                    streamActive = false;
                }
            } catch (error) {
                console.error("Error checking camera status:", error);
                cameraStatusText.textContent = "Error checking camera status.";
                showCameraPlaceholder(); // Show placeholder on error
                startCameraButton.style.display = 'block';
                startCameraButton.disabled = true;
                stopCameraButton.style.display = 'none';
                capturePhotoButton.style.display = 'none';
                capturePhotoButton.disabled = true;
                streamActive = false;
            }
        }

        function activateStreamUI() {
            // cameraFeedImg.src = "{{ url_for('main.camera_feed') }}?_nocache=" + new Date().getTime();
            showLiveFeed();
            startCameraButton.style.display = 'none';
            stopCameraButton.style.display = 'block';
            stopCameraButton.disabled = false;
            capturePhotoButton.style.display = 'block';
            capturePhotoButton.disabled = false;
            cameraStatusText.textContent = "Camera live."; // Ensure text is set here too
            streamActive = true;
        }

        function deactivateStreamUI(statusText = "Camera stopped.") {
            showCameraPlaceholder();
            startCameraButton.style.display = 'block';
            // If camera was available, start button should be enabled by checkCameraStatus or its direct handling path.
            // We only disable it if camera becomes unavailable.
            // startCameraButton.disabled = !rpi_camera_instance.is_available(); // This logic is now in checkCameraStatus

            stopCameraButton.style.display = 'none';
            capturePhotoButton.style.display = 'none';
            capturePhotoButton.disabled = true; 
            cameraStatusText.textContent = statusText;
            streamActive = false;
            // DO NOT call checkCameraStatus() here to prevent recursion.
            // The states of buttons should be managed by the function that led to deactivation or a fresh checkCameraStatus call.
        }

        startCameraButton.addEventListener('click', async () => {
            startCameraButton.classList.add('is-loading');
            startCameraButton.disabled = true;
            // cameraStatusText.textContent = "Starting camera...";
            showCameraLoading("Starting camera...");
            capturePhotoButton.disabled = true; // Disable capture while starting
            try {
                const response = await fetch("{{ url_for('main.start_camera_stream') }}", { method: 'POST' });
                const result = await response.json();
                if (response.ok && result.success) {
                    activateStreamUI();
                } else {
                    const errorMsg = "Failed to start camera: " + (result.error || "Unknown error");
                    deactivateStreamUI(errorMsg); // This will call showCameraPlaceholder
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                }
            } catch (error) {
                console.error("Error starting camera:", error);
                const errorMsg = "Error starting camera: " + error.message;
                deactivateStreamUI(errorMsg); // This will call showCameraPlaceholder
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
            }
            startCameraButton.classList.remove('is-loading');
            // Button state will be set by checkCameraStatus called in deactivateStreamUI or by direct activation
        });

        stopCameraButton.addEventListener('click', async () => {
            stopCameraButton.classList.add('is-loading');
            stopCameraButton.disabled = true;
            capturePhotoButton.disabled = true; // Disable capture while stopping
            // cameraStatusText.textContent = "Stopping camera..."; // Replaced by showCameraLoading
            showCameraLoading("Stopping camera...");
            try {
                const response = await fetch("{{ url_for('main.stop_camera_stream') }}", { method: 'POST' });
                const result = await response.json();
                if (response.ok && result.success) {
                    // When stopping, we go to a state where camera is ready but not streaming.
                    // So, directly set that state rather than calling deactivateStreamUI which might call checkCameraStatus.
                    showCameraPlaceholder();
                    startCameraButton.style.display = 'block';
                    startCameraButton.disabled = false; // Camera is still available
                    stopCameraButton.style.display = 'none';
                    capturePhotoButton.style.display = 'none';
                    capturePhotoButton.disabled = true;
                    cameraStatusText.textContent = "Camera stopped. Press Start to resume.";
                    streamActive = false;
                } else {
                    const errorMsg = "Failed to stop camera: " + (result.error || "Unknown error");
                    cameraStatusText.textContent = errorMsg;
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                    stopCameraButton.disabled = false; 
                    if(streamActive) capturePhotoButton.disabled = false; // Re-enable if stream was active
                    else showCameraPlaceholder(); // Ensure placeholder if error and not streaming
                }
            } catch (error) {
                console.error("Error stopping camera:", error);
                const errorMsg = "Error stopping camera: " + error.message;
                cameraStatusText.textContent = errorMsg;
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                stopCameraButton.disabled = false; 
                if(streamActive) capturePhotoButton.disabled = false;
                else showCameraPlaceholder();
            }
            stopCameraButton.classList.remove('is-loading');
        });

        capturePhotoButton.addEventListener('click', async () => {
            capturePhotoButton.classList.add('is-loading');
            capturePhotoButton.disabled = true;
            startCameraButton.disabled = true; // Prevent starting during capture
            stopCameraButton.disabled = true; // Prevent stopping during capture
            
            // Clear previous messages
            if (captureMessagePlaceholder) captureMessagePlaceholder.innerHTML = '';
            displayNotification('Capturing and processing photo...', 'info', captureMessagePlaceholder);

            try {
                const response = await fetch("{{ url_for('main.capture_rpi_photo') }}", { method: 'POST' });
                const result = await response.json();

                if (response.ok && result.success) {
                    displayNotification(result.message || 'Photo captured and processed successfully!', 'success', captureMessagePlaceholder);
                    if (result.redirect_url) {
                        // Give a moment for the user to see the success message
                        setTimeout(() => {
                            window.location.href = result.redirect_url;
                        }, 1500);
                    } else if (result.warning) { // Handle cases where document creation might have failed
                        displayNotification(result.warning, 'warning', captureMessagePlaceholder);
                        // Stay on page, photo is processed, but doc needs manual creation
                    }
                } else {
                    const errorMsg = "Capture/Processing failed: " + (result.error || "Unknown error");
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                    capturePhotoButton.disabled = false; // Re-enable on failure
                }
            } catch (error) {
                console.error("Error capturing photo:", error);
                const errorMsg = "Error during capture: " + error.message;
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                capturePhotoButton.disabled = false; // Re-enable on error
            }
            // Don't remove loading immediately if redirecting, but do if staying on page
            if (!capturePhotoButton.disabled) { // Only remove if not disabled (i.e. not about to redirect)
                 capturePhotoButton.classList.remove('is-loading');
            }
            // Re-evaluate camera state for other buttons if not redirecting
            if (!capturePhotoButton.disabled) {
                 checkCameraStatus(); 
            }
        });

        async function updateAfStateUI() {
            try {
                const resp = await fetch("{{ url_for('main.camera_autofocus_state') }}");
                const data = await resp.json();
                if (data.available) {
                    afEnabled = (data.af_mode === 'Auto');
                    afBtnLabel.textContent = afEnabled ? 'Autofocus: On' : 'Autofocus: Off';
                    toggleAfBtn.classList.toggle('is-success', afEnabled);
                    toggleAfBtn.classList.toggle('is-light', !afEnabled);
                    afStatus.textContent = data.af_state ? `State: ${data.af_state}` : '';
                } else {
                    afBtnLabel.textContent = 'Autofocus: N/A';
                    afStatus.textContent = '';
                }
            } catch (e) {
                afBtnLabel.textContent = 'Autofocus: Err';
                afStatus.textContent = '';
            }
        }
        toggleAfBtn.addEventListener('click', async () => {
            afEnabled = !afEnabled;
            afBtnLabel.textContent = '...';
            await fetch("{{ url_for('main.camera_set_autofocus') }}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: afEnabled })
            });
            setTimeout(updateAfStateUI, 400); // Give camera time to update
        });
        oneshotAfBtn.addEventListener('click', async () => {
            oneshotAfBtn.classList.add('is-loading');
            await fetch("{{ url_for('main.camera_trigger_autofocus') }}", { method: 'POST' });
            setTimeout(() => {
                oneshotAfBtn.classList.remove('is-loading');
                updateAfStateUI();
            }, 600);
        });

        // Initial check
        checkCameraStatus();
        updateAfStateUI();
    } // End of camera_available block

    // Generic handler for dismissing server-side flash messages (if any remain)
    document.querySelectorAll('.notification .delete').forEach((deleteButton) => {
        if (!deleteButton.dataset.listenerAttached) { // Avoid double-binding if displayNotification already handled it
            deleteButton.addEventListener('click', () => {
                deleteButton.parentElement.remove();
            });
            deleteButton.dataset.listenerAttached = 'true';
        }
    });
});
</script>
{% endblock %} 