{% extends "base.html" %}
{% block title %}Upload & Process Image{% endblock %}

{% block head %}
{{ super() }}
<style>
    .upload-page-container {
        max-width: 600px;
        margin: 3rem auto; /* Vertical margin for better spacing */
    }
    .camera-feed {
        max-width: 100%;
        height: auto;
        border: 1px solid #4a4a4a; /* From style.css */
        margin-bottom: 1rem;
        border-radius: 4px; /* From style.css */
        background-color: #2c2c2c; /* Match input fields */
        min-height: 240px; /* Default minimum height */
    }
    .file-label .file-name {
        border-width: 1px; /* Ensure file name area also has border */
    }
    /* For loading spinner on buttons */
    .button.is-loading::after {
        border-color: transparent transparent #fff #fff !important; /* White spinner for dark buttons */
    }
    #rpi-camera-section .subtitle,
    #rpi-camera-section-unavailable .subtitle {
        min-height: 2.5em; /* Space for status messages */
        padding-bottom: 0.5rem;
    }
    .camera-feed-container {
        position: relative;
        display: none; /* Initially hidden, shown by JS */
        justify-content: center;
        align-items: center;
        background: #232323; /* Dark background for the container */
        border-radius: 12px; /* Slightly less than card, more than image */
        border: 1.5px solid #333;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.10);
        margin: 0 auto 1.5em auto;
        padding: 0; /* Removed padding to make it wrap tightly */
        width: auto; /* Will be set by JS */
        height: auto; /* Will be set by JS */
        min-width: 200px; /* Minimum sensible size */
        min-height: 150px; /* Minimum sensible size */
        max-width: 100%; /* Constrained by parent */
        max-height: 70vh; /* Overall vertical constraint */
        overflow: hidden; /* Ensures rotated image doesn't break layout */
    }
    .camera-feed-container.visible {
        display: flex;
    }
    .camera-feed {
        display: none; /* Initially hidden */
        width: 100%;   /* Make image take full width of container */
        height: 100%;  /* Make image take full height of container */
        max-width: 100%; /* Redundant if width is 100% but good for clarity */
        max-height: 100%; /* Redundant if height is 100% but good for clarity */
        border-radius: 10px; /* Match container's inner feel if any bg shows */
        object-fit: contain;
        background: #181818; /* Background for the image area itself if transparent parts */
        /* box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10); /* Shadow on image might be too much if container has it */
        transition: transform 0.3s ease-in-out;
    }
    .camera-feed.visible {
        display: block;
    }
    .camera-feed.portrait {
        transform: rotate(90deg);
        /* Width/height for portrait are effectively swapped due to rotation */
        /* The JS will handle container size, image itself uses 100% of that rotated space */
        /* Ensure transform-origin is center for a good rotation effect */
        transform-origin: center center;
    }
    .camera-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9a9a9a;
        font-style: italic;
        z-index: 10;
    }
    .button.upload-flat {
        background: #ff8800;
        color: #fff;
        border: none;
        border-radius: 8px;
        box-shadow: none;
        font-weight: 600;
        font-size: 1.1rem;
        padding: 0.9em 0;
        transition: background 0.2s, box-shadow 0.2s;
        margin-top: 1.2em;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 100%;
        text-align: center;
        gap: 0.7em;
        letter-spacing: 0.01em;
    }
    .button.upload-flat:hover, .button.upload-flat:focus {
        background: #ff6a00;
        color: #fff;
        box-shadow: 0 2px 8px 0 rgba(255,136,0,0.10);
    }
    .autofocus-controls {
        display: flex;
        gap: 1em;
        justify-content: center;
        align-items: center;
        margin-bottom: 1em;
    }
    .autofocus-status {
        font-size: 0.95em;
        color: #6ee7b7;
        margin-left: 0.5em;
    }
    .upload-box-label {
        color: #e0e0e0;
        font-weight: 600;
        margin-bottom: 0.5em;
        display: block;
        text-align: left;
    }
    .custom-file-upload {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        background: #1de9b6;
        border-radius: 999px;
        padding: 0.7em 2.2em;
        cursor: pointer;
        transition: background 0.2s;
        border: none;
        margin-bottom: 1.2em;
        color: #222;
        font-size: 1.08em;
        font-weight: 500;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.08);
        width: auto;
        min-width: 180px;
        max-width: 100%;
        gap: 0.7em;
    }
    .custom-file-upload:hover, .custom-file-upload:focus {
        background: #13bfa6;
        color: #111;
    }
    .custom-file-upload .file-icon {
        font-size: 1.3em;
        margin-bottom: 0;
    }
    .file-input {
        display: none;
    }
    .file-name {
        color: #e0e0e0;
        background: #181818;
        border: 1.5px solid #333;
        border-radius: 10px;
        padding: 1em 1.2em;
        width: 100%;
        text-align: center;
        font-size: 1.08em;
        margin-bottom: 1.2em;
        margin-top: 0;
        box-sizing: border-box;
        min-height: 2.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        letter-spacing: 0.01em;
        box-shadow: 0 1px 4px 0 rgba(0,0,0,0.07);
    }
    .box#upload-box {
        background: #181818;
        border-radius: 14px;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.12);
        padding: 2.5em 2em 2em 2em;
    }
    .box#upload-box h1,
    .box#upload-box p,
    .box#upload-box label,
    .box#upload-box .file-name {
        color: #e0e0e0;
    }
    .upload-page-container form .field {
        margin-bottom: 0.5em;
    }
    .autofocus-controls button#toggle-af-btn.autofocus-on {
        background: #10b981;
        color: #fff;
        border: none;
        box-shadow: 0 2px 8px 0 rgba(16,185,129,0.10);
    }
    .autofocus-controls button#toggle-af-btn.autofocus-off {
        background: #232323;
        color: #e0e0e0;
        border: none;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
    }
    .autofocus-controls button#toggle-af-btn {
        transition: background 0.2s, color 0.2s;
    }
    /* Main button style for all major actions */
    .button-main {
        background: #ff8800;
        color: #fff;
        border: none;
        border-radius: 12px;
        font-weight: 600;
        font-size: 1.08em;
        padding: 0.85em 0;
        width: 100%;
        max-width: 100%;
        min-width: 200px;
        min-height: 2.8em;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.7em;
        box-shadow: 0 2px 8px 0 rgba(255,136,0,0.10);
        transition: background 0.2s, color 0.2s, box-shadow 0.2s;
        margin-bottom: 1em;
        letter-spacing: 0.01em;
    }
    .button-main:hover, .button-main:focus {
        background: #ff6a00;
        color: #fff;
        box-shadow: 0 2px 12px 0 rgba(255,136,0,0.18);
    }
    /* File input label as button */
    .custom-file-upload {
        cursor: pointer;
        background: #232323;
        color: #fff;
        border-radius: 12px;
        border: 1.5px solid #333;
        font-size: 1.08em;
        font-weight: 500;
        width: 100%;
        min-width: 200px;
        min-height: 2.8em;
        max-width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.7em;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
        margin-bottom: 1em;
        transition: background 0.2s, color 0.2s, box-shadow 0.2s;
    }
    .custom-file-upload:hover, .custom-file-upload:focus {
        background: #ff8800;
        color: #fff;
        border-color: #ff8800;
        box-shadow: 0 2px 12px 0 rgba(255,136,0,0.18);
    }
    .custom-file-upload .file-icon {
        font-size: 1.2em;
        margin-bottom: 0;
    }
    .file-input {
        display: none;
    }
    .file-name {
        color: #fff;
        background: #232323;
        border: 1.5px solid #333;
        border-radius: 12px;
        padding: 1em 1.2em;
        width: 100%;
        min-width: 200px;
        min-height: 2.8em;
        max-width: 100%;
        text-align: center;
        font-size: 1.08em;
        margin-bottom: 1.2em;
        margin-top: 0;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
        letter-spacing: 0.01em;
        box-shadow: 0 1px 4px 0 rgba(0,0,0,0.07);
    }
    .box#upload-box {
        background: #181818;
        border-radius: 16px;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.12);
        padding: 2.5em 2em 2em 2em;
    }
    .box#upload-box h1,
    .box#upload-box p,
    .box#upload-box label,
    .box#upload-box .file-name {
        color: #e0e0e0;
        text-align: center;
    }
    .upload-page-container form .field {
        margin-bottom: 0.5em;
    }
    /* Camera preview box */
    .camera-feed-container {
        position: relative;
        display: none;
        justify-content: center;
        align-items: center;
        background: #232323;
        border-radius: 16px;
        border: 1.5px solid #333;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.10);
        margin: 0 auto 1.5em auto;
        padding: 0.5em;
        width: auto;
        min-width: 0;
        min-height: 0;
        max-width: 100%;
        max-height: 70vh;
    }
    .camera-feed-container.visible {
        display: flex;
    }
    .camera-feed {
        display: none;
        max-width: 100%;
        max-height: 60vh;
        width: auto;
        height: auto;
        border-radius: 12px;
        object-fit: contain;
        background: #181818;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
        transition: transform 0.3s;
    }
    .camera-feed.visible {
        display: block;
    }
    .camera-feed.portrait {
        transform: rotate(90deg);
        max-width: 60vh;
        max-height: 100vw;
    }
    .camera-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #9a9a9a;
        font-style: italic;
        z-index: 10;
    }
    .button.upload-flat {
        background: #ff8800;
        color: #fff;
        border: none;
        border-radius: 8px;
        box-shadow: none;
        font-weight: 600;
        font-size: 1.1rem;
        padding: 0.9em 0;
        transition: background 0.2s, box-shadow 0.2s;
        margin-top: 1.2em;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 100%;
        text-align: center;
        gap: 0.7em;
        letter-spacing: 0.01em;
    }
    .button.upload-flat:hover, .button.upload-flat:focus {
        background: #ff6a00;
        color: #fff;
        box-shadow: 0 2px 8px 0 rgba(255,136,0,0.10);
    }
    .autofocus-controls {
        display: flex;
        gap: 1em;
        justify-content: center;
        align-items: center;
        margin-bottom: 1em;
    }
    .autofocus-status {
        font-size: 0.95em;
        color: #6ee7b7;
        margin-left: 0.5em;
    }
    .upload-box-label {
        color: #e0e0e0;
        font-weight: 600;
        margin-bottom: 0.5em;
        display: block;
        text-align: left;
    }
    .custom-file-upload {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        background: #1de9b6;
        border-radius: 999px;
        padding: 0.7em 2.2em;
        cursor: pointer;
        transition: background 0.2s;
        border: none;
        margin-bottom: 1.2em;
        color: #222;
        font-size: 1.08em;
        font-weight: 500;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.08);
        width: auto;
        min-width: 180px;
        max-width: 100%;
        gap: 0.7em;
    }
    .custom-file-upload:hover, .custom-file-upload:focus {
        background: #13bfa6;
        color: #111;
    }
    .custom-file-upload .file-icon {
        font-size: 1.3em;
        margin-bottom: 0;
    }
    .file-input {
        display: none;
    }
    .file-name {
        color: #e0e0e0;
        background: #181818;
        border: 1.5px solid #333;
        border-radius: 10px;
        padding: 1em 1.2em;
        width: 100%;
        text-align: center;
        font-size: 1.08em;
        margin-bottom: 1.2em;
        margin-top: 0;
        box-sizing: border-box;
        min-height: 2.5em;
        display: flex;
        align-items: center;
        justify-content: center;
        letter-spacing: 0.01em;
        box-shadow: 0 1px 4px 0 rgba(0,0,0,0.07);
    }
    .box#upload-box {
        background: #181818;
        border-radius: 14px;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.12);
        padding: 2.5em 2em 2em 2em;
    }
    .box#upload-box h1,
    .box#upload-box p,
    .box#upload-box label,
    .box#upload-box .file-name {
        color: #e0e0e0;
    }
    .upload-page-container form .field {
        margin-bottom: 0.5em;
    }
    .autofocus-controls button#toggle-af-btn.autofocus-on {
        background: #10b981;
        color: #fff;
        border: none;
        box-shadow: 0 2px 8px 0 rgba(16,185,129,0.10);
    }
    .autofocus-controls button#toggle-af-btn.autofocus-off {
        background: #232323;
        color: #e0e0e0;
        border: none;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
    }
    .autofocus-controls button#toggle-af-btn {
        transition: background 0.2s, color 0.2s;
    }
</style>
{% endblock %}

{% block content %}
<section class="section">
    <div class="container upload-page-container">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="notification is-{{ 'danger' if category == 'error' else category }} is-light is-small mb-4" id="flash-message-{{ loop.index }}">
                        <button class="delete is-small" onclick="this.parentElement.remove();"></button>
                        {{ message }}
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}

        <div class="box" id="upload-box">
            <h1 class="title is-3 has-text-centered">Process New Image</h1>
            <p class="subtitle is-6 has-text-centered has-text-grey-light mb-5">Upload an image file (PNG, JPG, WEBP) to extract text.</p>
            
            <form method="POST" action="{{ url_for('main.process_upload') }}" enctype="multipart/form-data" id="upload-form">
                <div class="field">
                    <label class="upload-box-label" for="file-upload-input">Image File</label>
                    <label class="button-main" tabindex="0">
                        <span class="file-icon"><i class="fas fa-upload"></i></span>
                        <span class="file-label">Choose a file...</span>
                        <input class="file-input" type="file" name="file" accept="image/png, image/jpeg, image/webp" id="file-upload-input">
                    </label>
                    <span class="file-name">No file selected</span>
                </div>
                <div id="upload-form-error-placeholder" class="mt-2"></div>
                <div class="field mt-5">
                    <div class="control has-text-centered">
                        <button type="submit" class="button-main" id="upload-submit-button">
                            <span class="icon"><i class="fas fa-cogs"></i></span>
                            <span>Upload and Process</span>
                        </button>
                    </div>
                </div>
            </form>
        </div>

        {% if camera_available %}
        <div class="box mt-5" id="rpi-camera-section">
            <h2 class="title is-4 has-text-centered">RPi Camera</h2>
            <p class="subtitle is-6 has-text-centered has-text-grey-light mb-4" id="camera-status-text">Checking camera status...</p>
            <div class="has-text-centered mb-3 autofocus-controls">
                <button class="button is-small is-rounded" id="toggle-portrait-btn" type="button" disabled>
                    <span class="icon"><i class="fas fa-mobile-alt"></i></span>
                    <span id="portrait-btn-label">Portrait Mode: Off</span>
                </button>
                <button class="button is-small is-rounded autofocus-off" id="toggle-af-btn" type="button" disabled>
                    <span class="icon"><i class="fas fa-bullseye"></i></span>
                    <span id="af-btn-label">Autofocus: ...</span>
                </button>
                <button class="button is-small is-rounded" id="oneshot-af-btn" type="button" disabled>
                    <span class="icon"><i class="fas fa-crosshairs"></i></span>
                    <span>One-Shot AF</span>
                </button>
                <span class="autofocus-status" id="af-status"></span>
            </div>
            <div class="has-text-centered camera-feed-container" id="camera-feed-container">
                 <img src="" alt="Camera Feed" id="camera-feed-img" class="camera-feed"/>
                 <div class="camera-loading-overlay" id="camera-loading-overlay" style="display: none;">Loading camera...</div>
            </div>
            <button class="button-main mb-2 mt-4" id="start-camera-btn" disabled>
                <span class="icon"><i class="fas fa-video"></i></span>
                <span>Start Camera</span>
            </button>
            <button class="button-main mb-2 mt-4" id="stop-camera-btn" style="display:none;">
                <span class="icon"><i class="fas fa-video-slash"></i></span>
                <span>Stop Camera</span>
            </button>
            <button class="button-main" id="capture-photo-btn" style="display:none;" disabled>
                <span class="icon"><i class="fas fa-camera"></i></span>
                <span>Capture Photo & Process</span>
            </button>
            <div id="capture-message-placeholder" class="mt-3"></div>
        </div>
        {% else %}
        <div class="box mt-5 is-hidden-touch" id="rpi-camera-section-unavailable">
             <h2 class="title is-4 has-text-centered">RPi Camera</h2>
             <p class="subtitle is-6 has-text-centered has-text-grey-light mb-4">RPi Camera feature is not available on this device or the camera is not detected.</p>
             <div class="has-text-centered">
                <span class="icon is-large has-text-grey-light"><i class="fas fa-exclamation-triangle fa-3x"></i></span>
             </div>
        </div>
        {% endif %}
    </div>
</section>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('file-upload-input');
    const fileNameDisplay = document.querySelector('.file-name');
    if (fileInput && fileNameDisplay) {
        fileInput.onchange = () => {
            if (fileInput.files.length > 0) {
                fileNameDisplay.textContent = fileInput.files[0].name;
            } else {
                fileNameDisplay.textContent = "No file selected";
            }
        }
    }

    const uploadForm = document.getElementById('upload-form');
    const uploadSubmitButton = document.getElementById('upload-submit-button');
    const uploadFormErrorPlaceholder = document.getElementById('upload-form-error-placeholder');

    if (uploadForm && uploadSubmitButton) {
        uploadForm.addEventListener('submit', (event) => {
            if (fileInput && fileInput.files.length === 0) {
                event.preventDefault();
                displayNotification('Please select a file to upload.', 'warning', uploadFormErrorPlaceholder, true);
                return;
            }
            uploadSubmitButton.classList.add('is-loading');
            uploadSubmitButton.disabled = true;
        });
    }

    function displayNotification(message, type = 'info', container, isFormError = false) {
        if (!container) {
            console.warn("Notification container not found for message:", message);
            // Fallback to a generic alert if no container and not a form error
            if(!isFormError) alert(message);
            return;
        }
        let notificationDiv = container.querySelector('.notification'); // Try to reuse existing for form errors
        if (!notificationDiv || !isFormError) { // Always create new for non-form errors or if no existing
            if(isFormError) container.innerHTML = ''; // Clear previous form error
            notificationDiv = document.createElement('div');
            notificationDiv.className = `notification is-${type} is-light is-small mb-3`;
            container.appendChild(notificationDiv);
        } else { // Update existing form error notification
             notificationDiv.className = `notification is-${type} is-light is-small mb-3`; // Update class for new type
        }
        
        notificationDiv.innerHTML = `<button class="delete is-small"></button>${message}`;
        const deleteButton = notificationDiv.querySelector('.delete');
        if (deleteButton) {
            deleteButton.addEventListener('click', () => notificationDiv.remove());
        }
    }

    const cameraSection = document.getElementById('rpi-camera-section');
    if (cameraSection) { // Only run camera JS if the section is present (i.e., camera_available was true)
        const cameraFeedImg = document.getElementById('camera-feed-img');
        const cameraFeedContainer = document.getElementById('camera-feed-container');
        const cameraLoadingOverlay = document.getElementById('camera-loading-overlay');
        const startCameraButton = document.getElementById('start-camera-btn');
        const stopCameraButton = document.getElementById('stop-camera-btn');
        const capturePhotoButton = document.getElementById('capture-photo-btn');
        const cameraStatusText = document.getElementById('camera-status-text');
        const captureMessagePlaceholder = document.getElementById('capture-message-placeholder');
        const togglePortraitBtn = document.getElementById('toggle-portrait-btn');
        const portraitBtnLabel = document.getElementById('portrait-btn-label');
        const toggleAfBtn = document.getElementById('toggle-af-btn');
        const afBtnLabel = document.getElementById('af-btn-label');
        const oneshotAfBtn = document.getElementById('oneshot-af-btn');
        const afStatus = document.getElementById('af-status');
        let portraitMode = false;
        let afEnabled = false;
        let streamActive = false;

        function updatePortraitButton() {
            const img = cameraFeedImg;
            const container = cameraFeedContainer;
            
            if (portraitMode) {
                portraitBtnLabel.textContent = 'Portrait Mode: On';
                img.classList.add('portrait');
            } else {
                portraitBtnLabel.textContent = 'Portrait Mode: Off';
                img.classList.remove('portrait');
            }

            setTimeout(() => {
                if (img.offsetParent === null || img.naturalWidth === 0 || img.naturalHeight === 0) {
                    console.warn("updatePortraitButton: Image not visible or no natural dimensions, skipping resize.");
                    // Optionally, reset container to default flexible state if image disappears
                    // container.style.width = 'auto'; 
                    // container.style.height = 'auto';
                    return;
                }

                // Get the visual dimensions of the <img> element itself after CSS rotation and object-fit
                const visualImgWidth = img.offsetWidth;
                const visualImgHeight = img.offsetHeight;
                console.log(`updatePortraitButton: Portrait=${portraitMode}, Visual img dimensions: W=${visualImgWidth}, H=${visualImgHeight}`);

                // The container should snugly fit these visual dimensions.
                let targetContainerWidth = visualImgWidth;
                let targetContainerHeight = visualImgHeight;

                // Apply container constraints (max-width: 100% of parent, max-height: 70vh)
                const containerParentWidth = container.parentElement.clientWidth;
                const viewportHeight = window.innerHeight;
                const maxContainerHeight = viewportHeight * 0.70;

                if (targetContainerWidth > containerParentWidth) {
                    targetContainerWidth = containerParentWidth;
                    // Recalculate height to maintain aspect ratio if width is clamped
                    if (visualImgWidth > 0) { // Avoid division by zero
                        targetContainerHeight = (visualImgHeight * targetContainerWidth) / visualImgWidth;
                    }
                }
                if (targetContainerHeight > maxContainerHeight) {
                    targetContainerHeight = maxContainerHeight;
                    // Recalculate width to maintain aspect ratio if height is clamped
                    if (visualImgHeight > 0) { // Avoid division by zero
                        targetContainerWidth = (visualImgWidth * targetContainerHeight) / visualImgHeight;
                    }
                }
                
                // Final check: if one dimension was clamped, the other might need clamping again if aspect ratio changed things
                 if (targetContainerWidth > containerParentWidth) targetContainerWidth = containerParentWidth;
                 if (targetContainerHeight > maxContainerHeight) targetContainerHeight = maxContainerHeight;


                container.style.width = `${Math.round(targetContainerWidth)}px`;
                container.style.height = `${Math.round(targetContainerHeight)}px`;
                
                console.log(`updatePortraitButton: Container set to W=${targetContainerWidth}, H=${targetContainerHeight}`);

                // The img tag is already width/height 100% of container, object-fit handles the rest.
                // No need to set img.style.maxWidth/Height here as it might conflict.
            }, 100); // Delay for browser to apply CSS transform and for image to reflow
        }
        togglePortraitBtn.addEventListener('click', async () => {
            portraitMode = !portraitMode;
            updatePortraitButton();
            try {
                await fetch("{{ url_for('main.toggle_camera_orientation') }}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: portraitMode })
                });
            } catch (e) {
                displayNotification('Failed to toggle portrait mode.', 'danger', captureMessagePlaceholder);
            }
            if (streamActive) {
                showLiveFeed();
            }
        });
        function showCameraLoading(text = "Loading camera...") {
            cameraFeedContainer.classList.remove('visible');
            cameraFeedImg.classList.remove('visible');
            cameraFeedImg.src = '';
            cameraLoadingOverlay.textContent = text;
            cameraLoadingOverlay.style.display = 'flex';
        }
        function showCameraPlaceholder() {
            cameraFeedContainer.classList.remove('visible');
            cameraFeedImg.classList.remove('visible');
            cameraFeedImg.src = '';
            cameraLoadingOverlay.style.display = 'none';
        }
        function showLiveFeed() {
            if (!cameraFeedImg || !cameraFeedContainer || !cameraLoadingOverlay) return;

            // Set a placeholder/loading appearance before src is set
            cameraFeedContainer.classList.add('visible'); // Show container
            cameraFeedImg.classList.remove('visible');   // Hide image until loaded
            cameraLoadingOverlay.style.display = 'flex'; // Show loading overlay
            cameraFeedImg.src = ''; // Clear previous src to ensure onload triggers for new one

            // Set the new source
            const feedUrl = "{{ url_for('main.camera_feed') }}?_nocache=" + new Date().getTime();
            cameraFeedImg.src = feedUrl;

            // Define what happens when the image successfully loads
            cameraFeedImg.onload = () => {
                console.log("camera_feed_img loaded. Dimensions:", cameraFeedImg.offsetWidth, cameraFeedImg.offsetHeight);
                cameraFeedImg.classList.add('visible');    // Show image
                cameraLoadingOverlay.style.display = 'none'; // Hide loading overlay
                updatePortraitButton(); // This will adjust container size based on loaded image
                // updateAfStateUI(); // AF state should be independent of image load, called by activateStreamUI
            };

            // Define what happens if the image fails to load
            cameraFeedImg.onerror = () => {
                console.error("Failed to load camera feed from URL:", feedUrl);
                cameraLoadingOverlay.textContent = 'Error loading feed.';
                cameraFeedImg.classList.remove('visible');
                // Optionally, call deactivateStreamUI or similar to handle feed error
                // For now, just shows error in overlay.
            };
        }

        async function checkCameraStatus() {
            showCameraLoading("Checking camera status...");
            startCameraButton.disabled = true;
            // Disable all controls initially
            capturePhotoButton.disabled = true;
            togglePortraitBtn.disabled = true;
            toggleAfBtn.disabled = true;
            oneshotAfBtn.disabled = true;

            try {
                const response = await fetch("{{ url_for('main.camera_status') }}");
                const data = await response.json();
                if (data.available) {
                    startCameraButton.disabled = false; 
                    if (data.streaming) {
                        activateStreamUI();
                        cameraStatusText.textContent = "Camera live."; 
                    } else {
                        deactivateStreamUI("Camera ready. Press Start.", false); // Keep start enabled
                    }
                } else {
                    cameraStatusText.textContent = data.message || "RPi Camera not available.";
                    deactivateStreamUI(data.message || "RPi Camera not available.", true); // All buttons remain disabled
                }
            } catch (error) {
                console.error("Error checking camera status:", error);
                const errorMsg = "Error checking camera status.";
                deactivateStreamUI(errorMsg, true); // All buttons remain disabled
            }
        }

        function activateStreamUI() {
            showLiveFeed();
            startCameraButton.style.display = 'none';
            stopCameraButton.style.display = 'block';
            stopCameraButton.disabled = false;
            
            capturePhotoButton.style.display = 'block';
            capturePhotoButton.disabled = false;
            togglePortraitBtn.disabled = false;
            // toggleAfBtn is enabled by its own updateAfStateUI logic
            oneshotAfBtn.disabled = false;
            
            cameraStatusText.textContent = "Camera live.";
            streamActive = true;
            setTimeout(updateAfStateUI, 500); // Call after a short delay post stream activation
        }

        function deactivateStreamUI(statusText = "Camera stopped.", disableAll = true) {
            showCameraPlaceholder();
            startCameraButton.style.display = 'block';
            startCameraButton.disabled = disableAll; // Only disable start if camera truly unavailable

            stopCameraButton.style.display = 'none';
            capturePhotoButton.style.display = 'none';
            
            // Disable all camera controls
            capturePhotoButton.disabled = true;
            togglePortraitBtn.disabled = true;
            toggleAfBtn.disabled = true; // Will be re-evaluated by updateAfStateUI if needed
            oneshotAfBtn.disabled = true;
            
            cameraStatusText.textContent = statusText;
            streamActive = false;
            if (disableAll) { // If camera system is off/error, ensure AF button reflects this
                updateAfStateUI(); // This will set AF button to N/A and disabled
            }
        }

        startCameraButton.addEventListener('click', async () => {
            startCameraButton.classList.add('is-loading');
            startCameraButton.disabled = true;
            // Ensure all other controls are disabled during start attempt
            capturePhotoButton.disabled = true;
            togglePortraitBtn.disabled = true;
            toggleAfBtn.disabled = true;
            oneshotAfBtn.disabled = true;

            showCameraLoading("Starting camera...");
            try {
                const response = await fetch("{{ url_for('main.start_camera_stream') }}", { method: 'POST' });
                const result = await response.json();
                if (response.ok && result.success) {
                    activateStreamUI();
                } else {
                    const errorMsg = "Failed to start camera: " + (result.error || "Unknown error");
                    deactivateStreamUI(errorMsg); // This will call showCameraPlaceholder
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                }
            } catch (error) {
                console.error("Error starting camera:", error);
                const errorMsg = "Error starting camera: " + error.message;
                deactivateStreamUI(errorMsg); // This will call showCameraPlaceholder
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
            }
            startCameraButton.classList.remove('is-loading');
            // If successful, activateStreamUI enables buttons. 
            // If failed, checkCameraStatus or direct call to deactivateStreamUI handles button states.
            if (!streamActive && !startCameraButton.disabled) { // If failed and start button is not disabled by higher logic
                 startCameraButton.disabled = false; // Re-enable start if it failed but camera still available
            }
        });

        stopCameraButton.addEventListener('click', async () => {
            stopCameraButton.classList.add('is-loading');
            stopCameraButton.disabled = true;
            // Disable all controls when stopping
            capturePhotoButton.disabled = true;
            togglePortraitBtn.disabled = true;
            toggleAfBtn.disabled = true;
            oneshotAfBtn.disabled = true;

            showCameraLoading("Stopping camera...");
            try {
                const response = await fetch("{{ url_for('main.stop_camera_stream') }}", { method: 'POST' });
                const result = await response.json();
                if (response.ok && result.success) {
                    deactivateStreamUI("Camera stopped. Press Start to resume.", false); // Keep start enabled
                } else {
                    const errorMsg = "Failed to stop camera: " + (result.error || "Unknown error");
                    cameraStatusText.textContent = errorMsg;
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                    stopCameraButton.disabled = false; 
                    if(streamActive) { // Re-enable controls if stop failed AND stream was/is active
                        activateStreamUI(); // This will re-enable appropriate buttons
                    } else { // Stream not active, ensure they stay disabled
                        deactivateStreamUI(errorMsg, true);
                    }
                }
            } catch (error) {
                console.error("Error stopping camera:", error);
                const errorMsg = "Error stopping camera: " + error.message;
                cameraStatusText.textContent = errorMsg;
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                stopCameraButton.disabled = false; 
                if(streamActive) {
                    activateStreamUI();
                } else {
                    deactivateStreamUI(errorMsg, true);
                }
            }
            stopCameraButton.classList.remove('is-loading');
        });

        capturePhotoButton.addEventListener('click', async () => {
            capturePhotoButton.classList.add('is-loading');
            // Disable all other camera interaction buttons during capture
            capturePhotoButton.disabled = true;
            startCameraButton.disabled = true; 
            stopCameraButton.disabled = true; 
            togglePortraitBtn.disabled = true;
            toggleAfBtn.disabled = true;
            oneshotAfBtn.disabled = true;
            
            // Clear previous messages
            if (captureMessagePlaceholder) captureMessagePlaceholder.innerHTML = '';
            displayNotification('Capturing and processing photo...', 'info', captureMessagePlaceholder);

            try {
                const response = await fetch("{{ url_for('main.capture_rpi_photo') }}", { method: 'POST' });
                const result = await response.json();

                if (response.ok && result.success) {
                    displayNotification(result.message || 'Photo captured and processed successfully!', 'success', captureMessagePlaceholder);
                    if (result.redirect_url) {
                        // Give a moment for the user to see the success message
                        setTimeout(() => {
                            window.location.href = result.redirect_url;
                        }, 1500);
                    } else if (result.warning) { // Handle cases where document creation might have failed
                        displayNotification(result.warning, 'warning', captureMessagePlaceholder);
                        // Stay on page, photo is processed, but doc needs manual creation
                    }
                } else {
                    const errorMsg = "Capture/Processing failed: " + (result.error || "Unknown error");
                    displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                    capturePhotoButton.disabled = false; // Re-enable on failure
                }
            } catch (error) {
                console.error("Error capturing photo:", error);
                const errorMsg = "Error during capture: " + error.message;
                displayNotification(errorMsg, 'danger', captureMessagePlaceholder);
                capturePhotoButton.disabled = false; // Re-enable on error
            }
            // Don't remove loading immediately if redirecting, but do if staying on page
            if (!capturePhotoButton.disabled) { // Only remove if not disabled (i.e. not about to redirect)
                 capturePhotoButton.classList.remove('is-loading');
            }
            // Re-evaluate camera state for other buttons if not redirecting
            if (!result.redirect_url) { // If not redirecting, re-check status to update buttons
                 checkCameraStatus(); 
            }
        });

        async function updateAfStateUI() {
            if (!toggleAfBtn) return;
            console.log("updateAfStateUI: Called");

            const originalBtnText = afBtnLabel.textContent;
            if (!toggleAfBtn.classList.contains('is-loading')) {
                 afBtnLabel.textContent = 'AF: Fetching...'; // More descriptive temp state
            }

            try {
                const resp = await fetch("{{ url_for('main.camera_autofocus_state') }}");
                const data = await resp.json();
                console.log("updateAfStateUI: Received data from backend:", JSON.stringify(data));

                if (data.available) {
                    const isCurrentlyContinuous = (data.af_mode === 2);
                    console.log(`updateAfStateUI: data.af_mode is ${data.af_mode}, isCurrentlyContinuous is ${isCurrentlyContinuous}`);
                    afEnabled = isCurrentlyContinuous; 
                    
                    afBtnLabel.textContent = isCurrentlyContinuous ? 'Autofocus: On' : 'Autofocus: Off';
                    toggleAfBtn.classList.toggle('autofocus-on', isCurrentlyContinuous);
                    toggleAfBtn.classList.toggle('autofocus-off', !isCurrentlyContinuous);
                    afStatus.textContent = ''; 
                    toggleAfBtn.disabled = false;
                    console.log("updateAfStateUI: Button state updated. afEnabled:", afEnabled, "Label:", afBtnLabel.textContent);
                } else {
                    console.log("updateAfStateUI: Autofocus system not available or error in data.");
                    afEnabled = false;
                    afBtnLabel.textContent = 'Autofocus: N/A';
                    toggleAfBtn.classList.remove('autofocus-on');
                    toggleAfBtn.classList.add('autofocus-off');
                    afStatus.textContent = '';
                    toggleAfBtn.disabled = true;
                }
            } catch (e) {
                console.error("Error in updateAfStateUI fetch:", e);
                afEnabled = false; 
                afBtnLabel.textContent = 'Autofocus: Err';
                toggleAfBtn.classList.remove('autofocus-on');
                toggleAfBtn.classList.add('autofocus-off');
                afStatus.textContent = '';
                toggleAfBtn.disabled = true; 
            }
        }

        toggleAfBtn.addEventListener('click', async () => {
            if (!streamActive) {
                displayNotification("Camera stream not active. Cannot toggle autofocus.", "warning", captureMessagePlaceholder);
                return;
            }
            
            // Current actual state is in global afEnabled, which updateAfStateUI maintains
            const targetEnabledState = !afEnabled; 
            
            afBtnLabel.textContent = targetEnabledState ? 'AF: Enabling...' : 'AF: Disabling...';
            toggleAfBtn.disabled = true;
            toggleAfBtn.classList.add('is-loading');
            console.log(`toggleAfBtn: Requesting AF to be set to: ${targetEnabledState} (current afEnabled: ${afEnabled})`);

            try {
                const response = await fetch("{{ url_for('main.camera_set_autofocus') }}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: targetEnabledState })
                });
                const result = await response.json();
                console.log('toggleAfBtn: Response from /camera_set_autofocus:', result);

                if (!response.ok || !result.success) {
                    console.error('toggleAfBtn: Failed to set autofocus via backend:', result.error || 'Unknown error');
                    displayNotification(`Failed to set autofocus: ${result.error || 'Server error'}`, 'danger', captureMessagePlaceholder);
                }
            } catch (e) {
                console.error('toggleAfBtn: Error POSTing to /camera_set_autofocus:', e);
                displayNotification('Error sending autofocus command.', 'danger', captureMessagePlaceholder);
            } finally {
                console.log("toggleAfBtn: Backend call finished. Scheduling updateAfStateUI.");
                setTimeout(() => {
                    console.log("toggleAfBtn: setTimeout executing updateAfStateUI.");
                    updateAfStateUI(); 
                    toggleAfBtn.classList.remove('is-loading');
                    // toggleAfBtn.disabled is handled by updateAfStateUI
                }, 1200); // Increased delay for camera hardware to report new state reliably
            }
        });

        oneshotAfBtn.addEventListener('click', async () => {
            if (!streamActive) {
                displayNotification("Camera stream not active. Cannot trigger one-shot AF.", "warning", captureMessagePlaceholder);
                return;
            }
            oneshotAfBtn.classList.add('is-loading');
            oneshotAfBtn.disabled = true; // Disable during operation
            toggleAfBtn.disabled = true; // Also disable continuous AF toggle during one-shot

            await fetch("{{ url_for('main.camera_trigger_autofocus') }}", { method: 'POST' });
            
            // After triggering, the AfMode might change (e.g. to Auto, then back to previous, or stay in Auto)
            // Give it time to complete the one-shot operation and then update the UI.
            setTimeout(() => {
                oneshotAfBtn.classList.remove('is-loading');
                oneshotAfBtn.disabled = false; 
                // toggleAfBtn.disabled = false; // updateAfStateUI will handle this one
                updateAfStateUI(); // Refresh AF state as it might have changed
            }, 1200); // Longer delay for one-shot AF to complete and state to settle
        });

        // Initial state setup
        // Call checkCameraStatus first, which then calls activate/deactivateStreamUI.
        // activateStreamUI will call updateAfStateUI.
        // If stream is not active initially, updateAfStateUI is called by deactivateStreamUI path in checkCameraStatus.
        checkCameraStatus(); 
        // updateAfStateUI(); // This call is likely redundant due to checkCameraStatus calling paths that include it.
    } // End of camera_available block

    // Generic handler for dismissing server-side flash messages (if any remain)
    document.querySelectorAll('.notification .delete').forEach((deleteButton) => {
        if (!deleteButton.dataset.listenerAttached) { // Avoid double-binding if displayNotification already handled it
            deleteButton.addEventListener('click', () => {
                deleteButton.parentElement.remove();
            });
            deleteButton.dataset.listenerAttached = 'true';
        }
    });
});
</script>
{% endblock %} 